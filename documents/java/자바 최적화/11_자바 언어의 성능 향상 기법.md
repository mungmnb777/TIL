# 11. 자바 언어의 성능 향상 기법

네트워크 연결, I/O, DB 등의 애플리케이션 외부 요인 다음으로 병목을 일으킬 공산이 가장 큰 부분이 바로 코드 설계이다. 설계는 바로 잡기가 지극히 어려울뿐더러 완벽한 설계란 없다.

데이터를 애플리케이션에 어떻게 저장할지는 매우 중요한 문제이다. 비즈니스 요건이 달라지면 데이터를 저장하는 방법도 달라질 수 밖에 없기 때문에 데이터를 저장할 때 어떤 옵션을 사용 가능할 지 이해하려면 개발자 스스로 자바 컬렉션 API가 지원하는 자료 구조 및 구현 세부를 꿰고 있어야 한다.

## 11.1. 컬렉션 최적화

대부분의 프로그래밍 언어 라이브러리는 최소한 두 가지 컨테이너를 제공한다.

- 순차 컨테이너 : 수치 인덱스로 표기한 특정 위치에 객체를 저장한다.
- 연관 컨테이너 : 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정한다.

컨테이너에서 메서드가 정확히 작동하려면 저장할 객체가 `호환성`과 `동등성` 개념을 지니고 있어야 한다.

자바는 메모리 서브시스템이 알아서 가비지 수집을 해주는 대신, 저수준의 메모리 제어를 포기할 수밖에 없다. 메모리 수동 할당/해제는 물론, 저수준 메모리 레이아웃 제어까지 단념해야 한다.

## 11.2. List 최적화

자바에서는 리스트를 ArrayList와 LinkedList, 두 가지 기본 형태로 나뉜다.

### 11.2.1. ArrayList

ArrayList는 고정 크기 배열에 기반한 리스트이다. 배열의 최대 크기만큼 원소를 추가할 수 있고 이 배열이 꽉 차면 더 큰 배열을 새로 할당한 다음 기존 값을 복사한다. ArrayList는 처음에 빈 배열로 시작하고 처음 원소가 추가될 때 용량 10인 기반 배열을 할당한다. 초기 용량값을 생성자에 전달하면 이렇게 크기 조정을 안 해도 된다. `ensureCapacity()` 메서드를 이용해 ArrayList 용량을 늘려도 크기 조정 작업을 건너뛸 수 있다.

```java
package jmh;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@Warmup(iterations = 20, time = 1)
@Measurement(iterations = 10, time = 1)
@OutputTimeUnit(TimeUnit.SECONDS)
@Fork(1)
public class ResizingList {

    private final String item = "*";

    @Benchmark
    public List<String> properlySizedArrayList() {
        List<String> list = new ArrayList<>(100_000);
        for(int i=0; i < 100_000; i++) {
            list.add(item);
        }
        return list;
    }

    @Benchmark
    public List<String> resizingArrayList() {
        List<String> list = new ArrayList<>();
        for(int i=0; i < 100_000; i++) {
            list.add(item);
        }
        return list;
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(ResizingList.class.getSimpleName())
                .jvmArgs("-server", "-Xms2048m", "-Xms2048m").build();

        new Runner(opt).run();
    }
}
```

JMH로 벤치마킹했을 때 실행 결과는 다음과 같다.

```java
Benchmark                             Mode  Cnt     Score    Error  Units
ResizingList.properlySizedArrayList  thrpt   10  3162.112 ± 23.842  ops/s
ResizingList.resizingArrayList       thrpt   10  2924.389 ± 24.331  ops/s
```

properlySizedArrayList가 약간 처리율이 더 높은 것을 알 수 있다.

### 11.2.2. LinkedList

LinkedList는 동적으로 증가하는 리스트이다. 이중 연결 리스트로 구현되어 있어서 리스트에 덧붙이는 작업은 항상 O(1)이다. 원소가 리스트에 더해질 때마다 노드가 생성되고 이 노드를 이전 원소가 바라본다.

### 11.2.3. ArrayList vs LinkedList

ArrayList, LinkedList 둘 중 어느 것을 쓸지는 데이터 접근/수정 패턴에 따라 다르다. 

리스트 끝에 원소를 삽입하는 작업은 ArrayList, LinkedList 모두 일정한 시간이 소요된다.

특정 인덱스에 원소를 삽입하는 작업은 ArrayList의 경우 다른 원소들을 모두 한 칸씩 우측으로 이동시켜야 하기 때문에 적지 않은 비용이 발생한다.

첫 번째 인덱스에 원소를 삽입하는 경우 ArrayList와 LinkedList의 처리율 차이를 JMH를 통해 비교해보자.

```java
package jmh;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@Warmup(iterations = 10, time = 1)
@Measurement(iterations = 10, time = 1)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Fork(1)
public class InsertBegin {
    private static final String item = "*";
    private static final int N = 1_000_000;

    private static List<String> arrayList = new ArrayList<>();
    private static List<String> linkedList = new LinkedList<>();

    @Setup(Level.Invocation)
    public static final void setup() {
        arrayList = new ArrayList<>();
        linkedList = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            arrayList.add(item);
            linkedList.add(item);
        }
    }

    @Benchmark
    public String beginArrayList() {
        arrayList.add(0, item);
        return arrayList.get(0);
    }

    @Benchmark
    public String beginLinkedList() {
        linkedList.add(0, item);
        return linkedList.get(0);
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(InsertBegin.class.getSimpleName())
                .jvmArgs("-server", "-Xms2048m", "-Xms2048m").build();

        new Runner(opt).run();
    }
}
```

실행 결과는 다음과 같다.

```java
Benchmark                     Mode  Cnt    Score    Error   Units
InsertBegin.beginArrayList   thrpt   10    3.532 ±  2.314  ops/ms
InsertBegin.beginLinkedList  thrpt   10  363.461 ± 34.291  ops/ms
```

LinkedList의 처리율이 130배 정도 더 높은 것을 확인할 수 있다. 원소 삭제도 마찬가지이다.

하지만 리스트를 랜덤으로 조회하는 경우에는 ArrayList가 훨씬 성능이 좋다. 모든 원소를 O(1)시간만에 가져올 수 있기 때문이다.

```java
package jmh;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@Warmup(iterations = 10, time = 1)
@Measurement(iterations = 10, time = 1)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Fork(1)
public class AccessingList {
    private static final String item = "*";
    private static final int N = 1_000_000;

    private static final List<String> arrayList = new ArrayList<>();
    private static final List<String> linkedList = new LinkedList<>();

    @Setup
    public static final void setup() {
        for (int i = 0; i < N; i++) {
            arrayList.add(item);
            linkedList.add(item);
        }
    }

    @Benchmark
    public String accessArrayList() {
        return arrayList.get(500_000);
    }

    @Benchmark
    public String accessLinkedList() {
        return linkedList.get(500_000);
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(AccessingList.class.getSimpleName())
                .jvmArgs("-server", "-Xms2048m", "-Xms2048m").build();

        new Runner(opt).run();
    }
}
```

실행 결과는 다음과 같다.

```java
Benchmark                        Mode  Cnt       Score      Error   Units
AccessingList.accessArrayList   thrpt   10  281230.417 ± 6270.311  ops/ms
AccessingList.accessLinkedList  thrpt   10       0.944 ±    0.042  ops/ms
```

ArrayList가 압도적으로 성능이 좋다.

따라서 LinkedList의 고유 기능이 필요한 경우가 아니라면, 특히 랜덤 액세스가 필요한 알고리즘을 구사할 때에는 ArrayList를 권장한다.