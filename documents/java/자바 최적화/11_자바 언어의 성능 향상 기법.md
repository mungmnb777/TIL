# 11. 자바 언어의 성능 향상 기법

네트워크 연결, I/O, DB 등의 애플리케이션 외부 요인 다음으로 병목을 일으킬 공산이 가장 큰 부분이 바로 코드 설계이다. 설계는 바로 잡기가 지극히 어려울뿐더러 완벽한 설계란 없다.

데이터를 애플리케이션에 어떻게 저장할지는 매우 중요한 문제이다. 비즈니스 요건이 달라지면 데이터를 저장하는 방법도 달라질 수 밖에 없기 때문에 데이터를 저장할 때 어떤 옵션을 사용 가능할 지 이해하려면 개발자 스스로 자바 컬렉션 API가 지원하는 자료 구조 및 구현 세부를 꿰고 있어야 한다.

## 11.1. 컬렉션 최적화

대부분의 프로그래밍 언어 라이브러리는 최소한 두 가지 컨테이너를 제공한다.

- 순차 컨테이너 : 수치 인덱스로 표기한 특정 위치에 객체를 저장한다.
- 연관 컨테이너 : 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정한다.

컨테이너에서 메서드가 정확히 작동하려면 저장할 객체가 `호환성`과 `동등성` 개념을 지니고 있어야 한다.

자바는 메모리 서브시스템이 알아서 가비지 수집을 해주는 대신, 저수준의 메모리 제어를 포기할 수밖에 없다. 메모리 수동 할당/해제는 물론, 저수준 메모리 레이아웃 제어까지 단념해야 한다.

## 11.2. List 최적화

자바에서는 리스트를 ArrayList와 LinkedList, 두 가지 기본 형태로 나뉜다.

### 11.2.1. ArrayList

ArrayList는 고정 크기 배열에 기반한 리스트이다. 배열의 최대 크기만큼 원소를 추가할 수 있고 이 배열이 꽉 차면 더 큰 배열을 새로 할당한 다음 기존 값을 복사한다. ArrayList는 처음에 빈 배열로 시작하고 처음 원소가 추가될 때 용량 10인 기반 배열을 할당한다. 초기 용량값을 생성자에 전달하면 이렇게 크기 조정을 안 해도 된다. `ensureCapacity()` 메서드를 이용해 ArrayList 용량을 늘려도 크기 조정 작업을 건너뛸 수 있다.

```java
package jmh;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@Warmup(iterations = 20, time = 1)
@Measurement(iterations = 10, time = 1)
@OutputTimeUnit(TimeUnit.SECONDS)
@Fork(1)
public class ResizingList {

    private final String item = "*";

    @Benchmark
    public List<String> properlySizedArrayList() {
        List<String> list = new ArrayList<>(100_000);
        for(int i=0; i < 100_000; i++) {
            list.add(item);
        }
        return list;
    }

    @Benchmark
    public List<String> resizingArrayList() {
        List<String> list = new ArrayList<>();
        for(int i=0; i < 100_000; i++) {
            list.add(item);
        }
        return list;
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(ResizingList.class.getSimpleName())
                .jvmArgs("-server", "-Xms2048m", "-Xms2048m").build();

        new Runner(opt).run();
    }
}
```

JMH로 벤치마킹했을 때 실행 결과는 다음과 같다.

```java
Benchmark                             Mode  Cnt     Score    Error  Units
ResizingList.properlySizedArrayList  thrpt   10  3162.112 ± 23.842  ops/s
ResizingList.resizingArrayList       thrpt   10  2924.389 ± 24.331  ops/s
```

properlySizedArrayList가 약간 처리율이 더 높은 것을 알 수 있다.