# 9. JVM의 코드 실행

## 9.1. 바이트코드 해석

JVM은 다음 세 공간에 주로 데이터를 담아둔다.

- 평가 스택: 메서드별로 하나씩 생성된다.
- 로컬 변수: 결과를 임시 저장한다.
- 객체 힙: 메서드끼리, 쓰레드끼리 공유된다.

### 9.1.1. JVM 바이트코드 개요

JVM에서 각 스택 머신 작업 코드(OPCODE)는 1바이트로 나타낸다. OPCODE는 0부터 255까지 지정 가능하며, 현재 약 200개를 사용하고 있다.

### 9.1.2. 단순 인터프리터

가장 단순한 인터프리터는 switch 문이 포함된 while 루프 형태이다.

### 9.1.3. 핫스팟에 특정한 내용

핫스팟은 상용 제품급 JVM이자 완전한 구현체이다. 뿐만 아니라, 인터프리티드 모드에서도 빠르게 실행될수 있도록 여러 고급 확장 기능을 가지고 있다.

핫스팟은 단순한 VM 작업을 구현하고 네이티브 플랫폼의 스택 프레임 레이아웃을 최대한 활용하여 성능을 조금이라도 높이기 위해 많은 어셈블리어 코드로 작성되어있다.

또, VMSpec에 없는 핫스팟 전용 바이트코드까지 정의해서 쓴다. 특정 OPCODE의 일반적인 유즈케이스와 빈번하게 호출되 사용되는 경우를 차별화하려는 의도이다.

이러한 설계 방식은 다양한 특이 사례를 다루는 데 도움이 된다. 예를들어 `final` 메서드는 오버라이드할 수 없으니 javac로 컴파일하면 `invokespecial` OPCODE가 나오리라 예상할 수 있다. 그러나 자바 언어 명세 3.4.17절에는 다음과 같은 문구가 있다.

<aside>
💡 final 메서드를 final 아닌 메서드로 변경하는 건 기존 바이너리와의 호환성을 깨뜨리지 않는다.

</aside>

다음 자바 코드를 보자.

```java
public class A {
	public final void fMethod() {
		// 작업 수행
	}
}

public class CallA {
	public void otherMethod(A obj) {
		obj.fMethod();
	}
}
```

`final` 메서드 호출부가 `invokespecial`로 컴파일되면 `CallA::otherMethod`는 다음 바이트 코드로 바뀔 것이다.

```java
public void otherMethod()
	Code:
		0: aload_1
		1: invokespecial #4
		4: return
```

이 때, `fMethod()`의 `final`이 지워진다면 이 메서드는 서브클래스에서 오버라이드할 수 있다. 서브클래스의 인스턴스를 `otherMethod()`의 인수로 넘기면 바이트코드 수준에서 `invokespecial` 명령어가 실행될 테니 메서드를 잘못 호출하게 될 것이다.

이것은 자바의 객체 지향 원칙을 위배하는 것이다. 특히 `리스코프 치환 원칙`을 어기게 된다.

## 9.2. AOT와 JIT 컴파일

### 9.2.1. AOT 컴파일

AOT 컴파일은 사람이 읽을 수 있는 프로그램 소스 코드를 외부 프로그램(컴파일러)에 넣고 바로 실행 가능한 기계어를 뽑아내는 과정이다.

AOT의 목표는 프로그램을 실행한 플랫폼과 프로세서 아키텍처에 딱 맞는 실행 코드를 얻는 것이다. 이렇게 대상이 고정된 바이너리는 프로세서별로 특수한 기능을 십분 활용해 프로그램 속도를 높일 수 있다.

### 9.2.2. JIT 컴파일

JIT 컴파일은 런타임에 프로그램을 고도로 최적화한 기계어로 변환하는 기법이다. 핫스팟을 비롯한 대부분의 주요 상용 JVM이 이 방식으로 작동된다.

## 9.3. 핫스팟 JIT 기초

핫스팟의 기본 컴파일 단위는 전체 메서드다. 한 메서드에 해당하는 바이트코드는 한꺼번에 네이티브 코드로 컴파일된다.

### 9.3.1. klass 워드, vtable, 포인터 스위즐링

JIT 컴파일 서브시스템을 구성하는 쓰레드는 핫스팟 내부에서 가장 중요한 쓰레드들이다. 컴파일 대상 메서드를 찾아내는 프로파일링 쓰레드와 실제 기계어를 생성하는 컴파일러 쓰레드도 다 여기에 포함된다.

컴파일 대상으로 낙점된 메서드는 컴파일러 쓰레드에 올려놓고 백그라운드에서 컴파일한다.

최적화된 기계어가 생성되면 해당 klass의 vtable은 새로 컴파일된 코드를 가리키도록 수정된다.

### 9.3.2. 핫스팟 내부의 컴파일러

핫스팟 JVM에는 C1, C2라는 두 JIT 컴파일러가 있다. 각각 클라이언트 컴파일러, 서버 컴파일러라고 부른다.

### 9.3.3. 핫스팟의 단계별 컴파일

자바 6부터 JVM은 단계별 컴파일 모드를 지원한다.

VM 내부에는 5개 실행 레벨이 존재한다.

- 레벨 0 : 인터프리터
- 레벨 1 : C1 - 풀 최적화(프로파일링 없음)
- 레벨 2 : C1 - 호출 카운터 + 백엣지 카운터
- 레벨 3 : C1 - 풀 프로파일링
- 레벨 4 : C2

단순 메서드는 일단 인터프리티드로 시작하지만 C1은 이 메서드가 정말 단순한지 판단할 수 있다. 따라서 C1 컴파일러가 C2보다 더 나은 코드를 낼 리는 없기 때문에 컴파일이 여기서 종료된다.

## 9.4. 코드 캐시

JIT 컴파일드 코드는 `코드 캐시`라는 메모리 영역에 저장된다. VM 시작 시 코드 캐시는 설정된 값으로 최대 크기가 고정되므로 확장이 불가하다. 코드 캐시가 꽉 차면 그때부터 더 이상 JIT 컴파일은 안 되며, 컴파일되지 않은 코드는 인터프리터에서만 실행된다.