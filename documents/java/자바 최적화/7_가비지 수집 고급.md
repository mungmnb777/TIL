# 7. 가비지 수집 고급

## 7.1. 트레이드오프와 탈착형 수집기

썬 마이크로시스템즈 환경 내부에서 GC는 탈착형 서브시스템으로 분류된다. 즉, 같은 자바 프로그램이라도 코드 변경 없이 여러 가지 가비지 수집기에서 돌려볼 수 있다.

이렇게 하는 이유는 GC가 모든 워크로드 유형에 다 적합한 건 아니기 때문이다.

개발자는 GC 선택 시 다음 항목을 고민해야 한다.

- 중단 시간
- 처리율(애플리케이션 런타임 대비 GC 시간 %)
- 중단 빈도(수집기 때문에 애플리케이션이 얼마나 자주 멈추는가?)
- 회수 효율(GC 사이클 당 얼마나 많은 가비지가 수집되는가?)
- 중단 일관성(중단 시간이 고른 편인가?)

## 7.2. 동시 GC 이론

범용 가비지 컬렉터는 중단 결정을 효과적으로 내리는 데 참고할 만한 도메인 지식이 전혀 없다. 더욱이, 메모리 할당은 불확정성을 유발하는 직접적인 원인으로 실제로도 많은 자바 응용 시스템에서 들쑥날쑥한 양상을 보인다.

최신 GC 이론은 불확정적 STW 중단 문제를 일단 해결하려고 시도한다.

동시 수집기를 써서 애플리케이션 쓰레드의 실행 도중 수집에 필요한 작업 일부를 수행해서 중단 시간을 줄이는 것도 한 방법이다.

### 7.2.1. JVM safepoint

> JVM은 사실 완전히 선제적인 멀티쓰레드 환경이 아니다.
> 

여기서 `선제적` 환경이라는 말은 JVM이 중간에 끼어들어 우선순위가 낮은 쓰레드를 끌어내리고 우선순위가 높은 쓰레드로 대체하는 것을 말한다. ( ↔ `협동적`)

JVM은 애플리케이션 쓰레드마다 `safepoint`라는 특별한 실행 지점을 둔다. `safepoint`는 쓰레드의 내부 자료 구조가 훤히 보이는 지점으로 여기서 어떤 작업을 하기 위해 쓰레드는 잠시 중단될 수 있다.

JVM은 다음 두 가지 규칙에 따라 `safepoint`를 처리한다.

- JVM은 강제로 쓰레드를 `safepoint` 상태로 바꿀 수 없다.
- JVM은 쓰레드가 `safepoint` 상태에서 벗어나지 못하게 할 수 있다.

따라서 `safepoint` 요청을 받았을 때 그 지점에서 쓰레드가 제어권을 반납하게 만드는 코드(`배리어`)가 VM 인터프리터 구현체 어딘가에 있어야 한다. 다음은 `safepoint` 상태로 바뀌는 몇 가지 일반적인 경우이다.

1. JVM이 전역 `time to safepoint` 플래그를 세팅한다.
2. 각 애플리케이션 쓰레드가 `polling`하면서 이 플래그가 세팅되었는지 확인한다.
3. 애플리케이션 쓰레드는 일단 멈췄다가 다시 깨어날 때까지 대기한다.

`time to safepoint` 플래그를 세팅하면 모든 애플리케이션 쓰레드는 반드시 멈춰야 한다. 일찍 멈춘 쓰레드는 느리게 멈추는 다른 쓰레드를 기다려야 한다.

다음은 인터프리터와 JIT 컴파일러가 `polling`하는 방식이다.

- 일반 애플리케이션 쓰레드는 인터프리터에서 바이트코드 2개를 실행할 때마다 체크하는 방식으로 폴링한다.
- 컴파일드 코드에서는 컴파일드 메서드 밖으로 나가거나 분기가 회기하는 지점에 JIT 컴파일러가 `safepoint` 폴링 코드를 삽입한다.

### 7.2.2. 삼색 마킹

삼색 마킹 알고리즘의 작동 원리는 다음과 같다.

1. GC 루트를 회색 표시한다.
2. 다른 객체는 모두 흰색 표시한다.
3. 마킹 쓰레드가 임의의 회색 노드로 이동한다.
4. 마킹 쓰레드가 흰색 표시된 자식 노드가 있는 노드를 만나면, 먼저 그 자식 노드를 모두 회색 표시한 뒤, 해당 노드를 검은색 표시한다.
5. 회색 노드가 하나도 남지 않을 때까지 위 과정을 되풀이한다.
6. 검은색 객체는 모두 접근 가능한 것이므로 살아남는다.
7. 흰색 노드는 더 이상 접근 불가한 객체이므로 수집 대상이 된다.

여기서 각각의 색이 정확히 무슨 역할을 하는지 알아보자.

- 회색
    - 해당 객체가 참조하고 있는 객체를 식별하지 않은, 즉 처리가 되지 않은 객체
- 검은색
    - 해당 객체가 참조하고 있는 객체를 모두 식별한, 즉 모든 처리를 끝마친 객체
- 흰색
    - 해당 객체가 참조하는 객체가 전혀 없는, 수집 대상이 되는 객체

동시 수집은 `SATB(snapshot at the beginning)`이라는 기법을 활용한다. 수집 사이클을 시작할 때 접근 가능하거나 그 이후에 할당된 객체를 라이브 객체로 간주하는 것이다.

## 7.3. CMS

CMS 수집기는 중단 시간을 아주 짧게 하려고 설계된 `old` 영역 전용 수집기이다.

CMS는 중단 시간을 최소화하기 위해 애플리케이션 쓰레드 실행 중에 가급적 많은 일을 한다. 삼색 마킹 알고리즘에 따라 마킹이 되므로 수집기가 힙을 탐색하는 도중에도 객체 그래프가 변경될 수 있다. 따라서 CMS는 가비지 수집기의 두번째 원칙인 `아직 살아 있는 객체를 수집하면 안 된다`를 위반하지 않도록 반드시 레코드를 바로잡아야 한다.

수행 단계는 다음과 같다.

1. 초기 마킹(STW)
    - `old` 영역 내부에 위치한 GC 출발점을 얻는 작업을 한다. 즉, `young` 영역에서 참조하는 `old` 영역 객체를 마킹한다.
2. 동시 마킹
    - 어플리케이션 쓰레드가 동시에 돌기 때문에 발생하는 변경 사항을 추적하며 체크한다.
3. 동시 사전 정리
    - 카드 테이블에 의해 더티 카드가 발견되고, 더티 카드에서 참조 관계가 변경되는 객체로부터 도달가능한 객체를 마킹한다. 작업이 끝난 더티 카드를 정리하기 위해 카드 테이블의 비트를 지운다.
4. 재마킹(STW)
5. 동시 스위프
6. 동시 리셋

1번, 4번 단계에서 STW가 실행되는데 전체적으로 한 차례 긴 STW 중단을 매우 짧은 두 차례 STW 중단으로 대체했다.

CMS는 다음과 같은 특징이 있다.

- 애플리케이션 쓰레드가 오랫동안 멈추지 않는다.
- 단일 풀 GC 사이클 시간이 더 길다
- CMS GC 사이클이 실행되는 동안, 애플리케이션 처리율은 감소한다
- GC가 객체를 추적해야 하므로 메모리를 더 많이 쓴다
- GC 수행에 훨씬 더 많은 CPU 시간이 필요하다
- CMS는 힙을 압착하지 않으므로 테뉴어드 영역은 단편화될 수 있다.

## 7.4. G1

G1은 병렬 수집기, CMS와는 전혀 스타일이 다르다. G1은 다음과 같은 특징이 있다.

- CMS보다 훨씬 튜닝하기 쉽다.
- 조기 승격에 덜 취약하다.
- 대용량 힙에서 확장성이 우수하다.
- 풀 STW 수집을 없앨 수 있다.

### 7.4.1. G1 힙 레이아웃 및 영역

G1 힙은 영역으로 구성된다. 영역은 디폴트 크기가 1메가바이트인 메모리 공간이다. 영역을 이용하면 세대를 불연속적으로 배치할 수 있고, 수집기가 매번 실행될 때마다 전체 가비지를 수집할 필요가 없다.

<p align="center">
    <img src="../../images/가비지 수집 고급_1.png"><br>
</p>

### 7.4.2. G1 알고리즘 설계

G1 수집기가 하는 일은 다음과 같다.

- 동시 마킹 단계를 이용한다.
- 방출 수집기다.
- 통계적으로 압착한다.

G1 수집기는 워밍업을 하는 동안, GC 사이클이 한번 돌 때마다 얼마나 많은 일반 영역에서 가비지를 수집할 수 있는지 그 수치를 보관한다. 제일 마지막에 GC가 발생한 이후로 새로 할당된 객체를 감당하기에 충분한 메모리를 수집할 수 있다면 G1은 할당보다 뒤처지지 않는다.

G1에서도 에덴, 서바이버 영역으로 이루어진 영 세대 개념은 같다. 다만 세대를 구성하는 영역이 연속되어있지는 않다.

### 7.4.3. 낮은 중단 시간

G1 GC의 낮은 중단 시간은 다음과 같은 특징 덕분에 얻을 수 있다.

- GC 시 전체 Heap에 대해 GC를 수행하지 않는다.
    - GC를 해야하는 영역만 수집한다.
    - `RSet`을 이용해서 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리한다.
- Old 영역 압착을 할 때에도 대상 영역에 대해서만 압착을 한다.
- 빈 공간을 먼저 확보하기 때문에 메모리의 여유 공간을 많이 확보할 수 있다. → GC 빈도 감소

### 7.4.4. Evacuation

G1 GC는 GC 이후에 살아남은 객체를 기존의 영역 혹은 새 영역에 복사한 후 메모리를 압착시킨다. 이를 `Evacuation`이라고 한다. Humongous 영역에 대해서는 `Evacuation`이 발생하지 않는다.

### 7.4.5. G1 단계

1. 초기 마킹
    - `old` 영역에 존재하는 객체들을 참조하는 `survivor` 영역을 찾아 마킹한다.
2. 동시 루트 탐색
3. 동시 마킹
    - `old` 영역에 생존한 모든 객체를 마킹한다. STW가 없기 때문에 어플리케이션 쓰레드와 동시에 돈다.
4. 재마킹
    - 어플리케이션을 멈추고 GC 대상에서 제외할 객체를 식별한다.
5. 정리
    - 어플리케이션을 멈추고 살아있는 객체가 가장 적은 영역의 미사용 객체를 제거한다.