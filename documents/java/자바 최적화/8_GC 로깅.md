# 8. GC 로깅, 모니터링, 튜닝, 툴

날짜: 2022년 9월 22일
세부 카테고리: 자바 최적화
카테고리: java

## 8.1. GC 로깅 개요

GC 로그는 시스템이 내려간 원인의 단서를 찾는 `cold case` 분석을 할 때 매우 유용하다. 파일에 쓰인 로그를 분석하는 작업이므로 애플리케이션 프로세스가 살아 있지 않아도 됩니다.

중요한 애플리케이션에는 다음 두 가지를 설정해야 한다.

- GC 로그를 생성한다.
- 애플리케이션 출력과는 별도로 특정 파일에 GC 로그를 보관한다.

### 8.1.1. GC 로깅 켜기

| 플래그 | 작용 |
| --- | --- |
| -Xloggc:gc.log | GC 이벤트에 로깅할 파일을 지정한다. |
| -XX:+PrintGCDetails | GC 이벤트 세부 정보를 로깅한다. |
| -XX:+PrintTenuringDistribution | 툴링에 꼭 필요한 부가적인 GC 이벤트 세부 정보를 추가한다. |
| -XX:+PrintGCTimeStamps | GC 이벤트 발생 시간을 (VM 시작 이후 경과한 시간을 초 단위로) 출력한다. |
| -XX:+PrintGCDateStamps | GC 이벤트 발생 시간을 (벽시계 시간 기준으로) 출력한다. |

### 8.1.2. GC 로그 vs JMX

VisualGC는 JMX 인터페이스를 통해 JVM 데이터를 수집한다. JMX는 GC에 영향을 주기 때문에 성능 엔지니어는 다음 사항을 숙지해야 한다.

- GC 로그 데이터는 실제로 가비지 수집 이벤트가 발생해서 쌓이지만, JMX는 데이터를 샘플링해서 얻는다.
- GC 로그 데이터는 캡처 영향도가 거의 없지만, JMX는 프록시 및 원격 메서드 호출 과정에서도 암묵적인 비용이 든다.
- GC 로그 데이터에는 자바 메모리 관리에 연관된 성능 데이터가 50가지 이상 있지만, JMX는 10가지도 안된다.

### 8.1.3. JMX의 단점

앞서 말했듯이 JMX는 런타임을 샘플링하여 현재 상태를 업데이트 받는다.

문제는 GC다. 수집기가 언제 실행될지 클라이언트가 알 도리가 없다. 그렇기 때문에 각 수집 전후의 메모리 상태 또한 알 수 없고, GC 데이터를 깊이 있게 분석할 수 없다.