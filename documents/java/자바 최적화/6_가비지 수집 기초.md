# 6. 가비지 수집 기초

GC 구현체는 다음 두 가지 기본 원칙을 준수해야 한다.

- 알고리즘은 반드시 모든 가비지를 수집해야 한다.
- 살아있는 객체는 절대로 수집해서 안된다.

특히 두 번째 원칙은 매우 중요하다. 살아있는 객체를 수집했다간 `segementation fault`가 발생하거나 프로그램 데이터가 더럽혀진다.

## 6.1. Mark And Sweep

가장 기본적인 Mark & Sweep 알고리즘은 할당됐지만 아직 회수되지 않은 객체를 가리키는 포인터를 포함한 할당 리스트를 사용한다. 전체적인 GC 알고리즘은 다음과 같다.

1. 할당 리스트를 순회하면서 `Mark bit`를 지운다.
2. GC 루트부터 살아있는 객체를 찾는다.
3. 이렇게 찾은 객체마다 `Mark bit`를 설정한다.
4. 할당 리스트를 순회하면서 `Mark bit`가 세팅되지 않은 객체를 찾는다.
    - 힙에서 메모리를 회수에 `free list`에 되돌린다.
    - 할당 리스트에서 객체를 삭제한다.

살아있는 객체는 대부분 DFS로 찾는다. 이렇게 해서 생성된 객체 그래프를 `라이브 객체 그래프`라고 한다.

### 6.1.1. GC 용어

- STW(Stop the world)
    - GC 사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 쓰레드가 중단된다.
    - 애플리케이션 코드는 GC 쓰레드가 바라보는 힙 상태를 무효화할 수 없다.
- 동시
    - GC 쓰레드는 애플리케이션 쓰레드와 동시에 실행될 수 있다. 이는 계산 비용 면에서 아주 어렵고 비싼 작업인데다, 실상 100% 동시 실행을 보장하는 알고리즘은 없다.
- 병렬
    - 여러 쓰레드를 동원해서 가비지 수집을 한다.
- 정확
    - 정확한 GC 스킴은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있다.
- 보수
    - 보수적인 스킴은 정확한 스킴의 정보가 없다.
    - 리소스를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 비효율적이다.
- 이동
    - 이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있다. → 객체 주소가 고정된 것이 아니다.
- 압착
    - 살아남은 객체는 GC 사이클 마지막에 연속된 단일 영역으로 배열된다. 압착 수집기는 메모리 단편화를 방지한다.
- 방출
    - 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동한다.

## 6.2. 핫스팟 런타임 개요

자바에서는 크게 두 가지 타입으로 나뉜다.

- 기본 타입(boolean, int 등)
- 객체 참조 타입

자바는 C++과 달리 주소를 역참조하는 일반적인 매커니즘이 없다. 오직 오프셋 연산자(`. 연산자`)만으로 필드에 액세스하거나 객체 레퍼런스의 메서드를 호출할 수 있다. 또 자바는 `call by value`로만 메서드를 호출한다.

### 6.2.1. 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 `oop`라는 구조체로 자바 객체를 나타낸다. `oop`는 `Ordinary Object Pointer`의 줄임말로 평범한 객체 포인터라는 의미이다. `oop`는 참조현 지역 변수 안에 위치한다. 여기서 자바 메서드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킨다.

`oop`를 구성하는 자료구조는 다음과 같다.

- `instanceOop` : 자바 클래스의 인스턴스
    - `Mark 워드` : 인스턴스 관련 메타데이터를 가리키는 포인터
    - `Klass 워드` : 클래스 메타데이터를 가리키는 포인터
        - `Klass 워드`의 경우 자바 7까지는 `PermGen`이라는 힙 영역을 가리켰다. 현재는 `PermGen`이 네이티브 스태틱 영역으로 옮겨가서 힙을 가리키지 않는다.
            
<p align="center">
    <img src="../../images/GC 기초_1.png"><br>
</p>

            

### 6.2.2. GC 루트 및 아레나

GC 루트는 메모리의 **고정점**으로 메모리 풀 외부에서 내부를 가리키는 포인터다. 메모리 풀 내부에서 같은 메모리 풀 내부의 다른 메모리 위치를 가리키는 내부 포인터와 다른 `외부 포인터`이다.

GC 루트는 다음과 같다.

- 스택 프레임
- JNI
- 레지스터
- 코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않는다. 유저 공간 코드에서 힙 크기를 관리하므로 단순 측정값을 이용해 GC 서브시스템이 어떤 성능 문제를 일으키고 있는지 파악할 수 있다.

## 6.3. 할당과 수명

자바 애플리케이션에서 가비지 수집이 일어나는 주된 원인은 다음 두 가지이다.

- 할당률
- 객체 수명

`할당률`은 일정 기간 새로 생성된 객체가 사용한 메모리량이다. 이 값은 `센섬` 같은 툴을 이용하면 정확하게 구할 수 있다.

`객체 수명`은 측정하기 어렵다. `수동 메모리 관리 시스템`에서 가장 논란이 됐던 부분 중 하나가 실제 애플리케이션에서 객체 수명을 제대로 파악하기가 너무 복잡하다는 것이다.

GC는 여러 가지 따져봐야 할 트레이드오프가 있는데 그 중 가장 중요한 것도 `할당 및 수명`과 연관되어 있다.

### 6.3.1. 약한 세대별 가설

`약한 세대별 가설`은 소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게 된 경험 지식으로 JVM 메모리 관리의 이론적 근간을 형성한다.

> JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보인다. 거의 대부분의 객체는 아주 짧은 시간만 살아있지만 나머지 객체는 기대 수명이 훨씬 길다.
> 

→ 가비지를 수집하는 힙은 단명 객체를 쉽고 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 것이 가장 좋다.

이에 따라 핫스팟은 몇 가지 매커니즘을 응용한다.

- 객체마다 `세대 카운트(객체가 지금까지 무사 통과한 GC 횟수)`를 센다.
- 큰 객체를 제외한 나머지 객체는 `Eden` 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
- 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 `Old` 공간에 보관한다.

## 6.4. 핫스팟의 가비지 수집

### 6.4.1. 쓰레드 로컬 할당

JVM은 성능을 강화해서 `Eden`을 강화한다. `Eden`은 대부분의 객체가 탄생하는 장소이고 단명 객체는 다른 곳에는 위치할 수 없으므로 특별히 관리를 잘해야 하는 영역이다.

JVM은 `Eden`을 여러 버퍼로 나누어 각 애플리케이션 쓰레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다. 이렇게 하면 각 쓰레드는 다른 쓰레드가 자신의 버퍼에 객체를 할당하는 것에 대한 걱정을 할 필요가 없다. 이 구역을 `쓰레드 로컬 할당 버퍼(TLAB)`이라고 한다.

<aside>
💡 핫스팟은 애플리케이션 쓰레드에 발급한 TLAB 크기를 동적으로 조정한다. 따라서 한 쓰레드가 메모리를 엄청나게 소모하고 있으면 쓰레드에 버퍼를 내주는 오버헤드를 줄이기 위해 더 큼지막한 TLAB를 건네준다.

</aside>

## 6.5. 병렬 수집기

자바 8 이전까지 JVM 디폴트 가비지 수집기는 `병렬 수집기`이다. 병렬 수집기는 처리율에 최적화되어 있고 `Young GC`, `Full GC` 모두 풀 STW를 일으킨다. 애플리케이션 쓰레드를 모두 중단시킨 다음 가용 CPU 코어를 총동원해 가능한 한 재빨리 메모리를 수집한다.

- `Parallel GC` : 가장 단순한 `Young Gen`용 병렬 수집기이다.
- `ParNew GC` : CMS 수집기와 함께 사용할 수 있게 Parallel GC를 조금 변형했다.
- `ParallelOld GC` : `Old Gen`용 병렬 수집기이다.

### 6.5.1. 영 세대 병렬 수집

쓰레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고 JVM은 새 TLAB를 할당할 수 없을 때 `영 세대 수집`이 발생한다. 그 과정은 다음과 같다.

1. JVM은 전체 애플리케이션 쓰레드를 중단시킨다.
2. 전체 애플리케이션 쓰레드가 중단된 후 핫스팟은 `Eden` 및 현재 비어있지 않은 `Survivor` 영역을 뒤져서 가비지가 아닌 객체를 골라낸다. 이 때 GC 루트를 병렬 마킹 스캔 작업의 출발점으로 삼는다.
3. `Parallel GC`는 살아남은 객체를 현재 비어있는 `Survivor` 영역으로 모두 `방출`하고 세대 카운트를 눌려 한 차례 이동했음을 기록한다.
4. `Eden` 영역과 막 객체들을 방출시킨 `Survivor` 영역을 재사용 가능한 빈 공간으로 표시하고 애플리케이션 쓰레드를 재시작한다.

### 6.5.2. 올드 세대 병렬 수집

`ParallelOld GC`는 Java 8 기준 기본 올드 세대 수집기이다. `Parallel GC`는 객체를 **방출**하는 반구형 수집기이지만 `ParallelOld GC`는 하나의 연속된 메모리 공간에서 **압착**하는 수집기이다. 

올드 세대에 더 이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 빠져 버려진 공간을 회수한다. 따라서 메모리 사용 면에서 효율적이고 메모리 단편화가 일어날 일이 없다.

### 6.5.3. 병렬 수집기의 한계

병렬 수집기는 풀 STW를 유발한다. `영 수집`의 경우에는 약한 세대별 가설에 따라 극소수 객체만 생존하기 때문에 STW가 문제되지 않는다.

하지만 `올드 수집`의 경우 디폴트 크기 자체가 영 세대의 7배나 된다. 또한 올드 객체는 `Full GC`에서도 상당 수가 살아남을 것으로 예상된다.

올드 수집의 가장 큰 약점은 STW 시간이 힙 크기에 거의 비례한다는 것이다. 힙이 계속 커질수록 `ParallelOld GC`의 중단 시간도 함께 나빠질 것이다.