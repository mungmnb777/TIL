# 운영체제 / 논리회로 일반

## 1. 컴퓨터는 10진수를 2진수로 바꿔서 계산합니다. 10진수를 2진수로 바꾸는 방법과, 그 반대 방법에 대해 설명해 주시기 바랍니다.

### 답변

10진수를 2진수로 바꾸는 방법은 10진수의 값을 나눈 나머지를 2진수의 첫 자리에 오게 하고, 몫을 다시 2로 나누어 나머지를 2진수의 둘째 자리에 오게하고, 또 몫을 2로 나누어 셋째 자리로 오게하고,, 이 과정을 몫이 0이 될 때까지 반복합니다.

반대로 2진수를 10진수로 바꾸는 방법은 2진수의 각 자리가 n일 때 ‘각 자리의 값 * $\left(2^{\smash{n-1}}\right)$’을 다 더해주면 됩니다.

### 추가 내용

컴퓨터 내부에는 수많은 트랜지스터가 있는데, 이 때 트랜지스터는 전기 신호로 작동하게 된다. 전기 신호가 들어오는 경우 컴퓨터는 이를 `1`로 인식하고, 전기신호가 없으면 `0`으로 인식하게 된다. 즉, 컴퓨터는 0과 1만을 구분할 수 있기 때문에 2진법을 기반으로 작동한다.

만약 10진수의 체계를 그대로 사용하려면 컴퓨터는 10개의 신호 단계를 거쳐야 하는데 전기 신호의 크기를 10단계로 나누면, 신호를 판단할 때 오류가 더 늘 것이다. 이에 비해 2진수는 신호가 있거나, 없거나 둘 중 하나이기 때문에 안전한 2진수 체계를 사용하는 것이다.

<br>

## 2. 컴퓨터는 소숫점 계산을 잘 못합니다. 그 이유가 무엇일까요? 어떻게 문제를 해결할 수 있을까요? 직접 구현한다면 어떻게 하시겠습니까?

### 답변

컴퓨터는 모든 계산을 2진수로 변환해서 계산합니다. 하지만 2진수로는 모든 수를 표현하기에는 한계가 있습니다. 소수 계산에서 오차가 많이 발생하는데, 소수의 2진수 형태는 각 자릿수가 $\frac{1}{2^{n-1}}$의 값을 가지는데 이 값들을 무한정 이어나가야 하는 경우가 있는데, 그러다 표현할 수 있는 범위를 넘어가게 되면 반올림 혹은 버림을 하여 근사값을 출력하고, 이 때 오차가 발생합니다.

이를 해결하기 위해 자바에서는 BigDecimal 클래스를 제공합니다. 해당 클래스는 내부적으로 수를 십진수로 저장하여 아주 작은 수와 큰 수의 연산에 대해 거의 무한한 정밀도를 보장합니다.

### 추가 내용

- BigDecimal 원리
    
    유효 숫자의 역할을 하는 `unscaledValue`와 32-bits의 `scale`로 이루어져 있다. 실제로 이 값들이 나타내는 BigDecimal 값은 unscaledValue * $10^{-scale}$이다.
    
    BigDecimal 클래스는 5개의 필드가 클래스를 표현하고 있다.
    
    - `intVal` : unscaledValue를 나타낸다. BigInteger 타입이다.
    - `scale` : scale을 나타낸다.
    - `precision` : 유효 숫자 개수를 나타내고 처음 계산되기 전까지는 0이다. 계산 이후 precision에 있는 값은 그 만큼의 정확성을 보장한다.
    - `stringCache` : Canonical string representation에 저장하기 위한 필드이다. 즉, 우리가 일반적으로 숫자를 쓸 때 그 표현법을 string으로 저장하고 있다.
    - `intCompact` : unscaledValue를 나타내지만 여기는 Long 타입이다.

<br>

## 3. Thread 간의 데이터 공유와 Process 간의 데이터 공유의 공통점과 차이점을 설명해주세요.

### 답변

프로세스와 쓰레드 모두 데이터 공유를 할 때 하나의 메모리에 동시에 접근해서 의사소통하게 됩니다. 하지만 쓰레드 통신의 경우 애초에 메모리 공간과 자원을 공유하기 때문에 데이터를 공유하기가 쉽지만, 프로세스는 생성될 때 메모리 공간을 복사하여 가상의 메모리를 사용하기 때문에 통신을 위한 별도의 공간을 만들어 주어야 합니다. 이를 위해서 커널 영역에서 IPC라는 내부 프로세스간 통신을 제공하게 되고, 프로세스는 커널이 제공하는 IPC를 이용해서 데이터를 공유할 수 있습니다.

### 추가 내용

1. **공유 메모리 (Shared Memory)**
    
    ![Untitled](../images/OS%26Logic_1.png)
    
    - 공유 메모리가 데이터 자체를 공유하도록 지원하는 설비. 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용한다.
    - 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당한다. 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.
    - 프로세스간 Read, Write를 모두 필요로 할 때 사용한다.
    - 대량의 정보를 다수의 프로세스에게 배포 가능하다.
    - 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 모든 IPC 중 가장 빠르게 작동한다.

2. **파이프(Pipe)**
    
    ![Untitled](../images/OS%26Logic_2.png)
    
    - 통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고 받게한다.
    - 익명 파이프(Anonymous Pipe)
        - 일반적인 파이프
        - 통신할 프로세스가 명확하게 알 수 있는 경우 사용
            - 부모-자식, 형제 프로세스 간 통신에 사용한다.
        - 파이프는 두 개의 프로세스를 연결하고, 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 할 수 있다. 한쪽 방향으로만 통신이 가능한 파이프의 특징 때문에 `반이중 통신`이라고 부르기도 한다.
        - 송/수신을 모두 하기 원한다면 두 개의 파이프를 만들어야 한다.
    - 네임드 파이프(Named Pipe)
        - 전혀 모르는 상태의 프로세스들 사이의 통신에 사용
        - 익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신할 수 있다.
            - 프로세스 통신을 위해 이름이 있는 파일을 사용하기 때문에 가능하다.
            - FIFO라 불리는 특수 파일을 이용해 서로 관련 없는 프로세스 간 통신에 사용한다.

3. **소켓(Socket)**
    
    ![Untitled](../images/OS%26Logic_3.png)
    
    - Unix 도메인 소켓 또는 IPC 소켓은 동일한 호스트 OS에서 실행되는 프로세스 간 데이터를 교환하기 위한 데이터 통신 엔드 포인트이다.
    - 네트워크 소켓 통신을 통해 데이터를 공유한다.
        - 데이터 교환을 위해 양쪽 PC에서 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고받는 방식이다.
        - 이 때 각각 PC의 포트를 담당하는 소켓은 각각 하나의 프로세스이다.
        - 즉, 해당 프로세스는 임의의 포트를 맡아 데이터를 송수신하는 역할을 진행하는 프로세스이다.
        - 각각의 PC에서 프로세스를 통해 타 PC 포트에 연결하라는 명령을 보내게 되면 두 프로세스는 서로 확인 과정을 거쳐 연결을 진행하고 연결 후 마치 Pipe와 같이 1:1로 데이터를 주고받는 방식이다.
    - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
    - `전이중 통신`이 가능하다.
    - 서버/클라이언트 환경을 구축하는데 용이하다.

4. **메세지 큐(Message Queue)**
    
    ![Untitled](../images/OS%26Logic_4.png)
    
    - 입출력 방식은 Named 파이프와 동일하다.
    - 메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.
    - PIPE와 FIFO와는 달리, 다수의 프로세스간 메시지를 전달할 수 있다.
    - 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
    - 메시지의 접근을 위해서는 키가 필요하다.

5. **메모리 맵(Memory Map)**
    
    ![Untitled](../images/OS%26Logic_5.png)
    
    - 공유 메모리처럼 메모리를 공유해준다.
    - 메모리 맵은 열린 파일을 메모리에 매핑시켜서 공유하는 방식이다.
    - 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.
    - File IO가 느릴 때 사용하면 좋다.
    - 대부분 운영 체제에서는 프로세스를 실행할 때 실행 파일의 각 세그먼트를 메모리에 사상하기 위해 메모리 맵 파일을 이용한다.

6. **RPC(Remote Procedure Call)**
    - RPC 방법은 분산 네트워크 망에서 많이 사용되는 방식이다.
    - 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스간 통신 기술이다. 다시 말해, 원격 프로시져 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.
    - 해당 방법은 분리된 PC에 저장된 데이터를 마치 내 PC에 존재하는 것처럼 데이터를 가져와 사용하는 통신 방법이다.
        - 스텁을 통해서 마치 자신의 디스크에 존재하는 것처럼 착각을 일으켜 사용하는 방식이다.
        - 프로시저: 루틴, 서브루틴, 함수와 같은 뜻으로 사용되며 하나의 프로시저는 특정 작업을 수행하기 위한 프로그램의 일부이다. 또는 어떤 행동을 수행하기 위한 일련의 작업 순서를 말한다.

<br>

## 4. 컴퓨터가 기계어를 읽고, 실행하는 과정에 대해 설명해 주실 수 있나요?

### 답변

컴퓨터의 여러 부품 중 기계어를 읽어와 실행하는 부품은 CPU입니다. CPU는 메모리와 통신하며 기계어로 된 데이터를 쓰거나 읽어옵니다. 그리고 읽어온 데이터는 명령어 집합을 통해 해독한 후 명령어 레지스터에 저장합니다. 그 후 프로그램 카운터의 신호에 따라 명령어 레지스터에 저장된 명령어를 실행하며 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치로 보냅니다.

### 추가 내용

- 메모리 셀
    - 메모리는 `셀`로 구성되어있다. 셀들을 구별하기 위해 주소 번호도 붙여둔다.
    - 메모리가 할 수 있는 데이터를 쓰거나 읽는 것이다. 이를 위해 셀을 조작해야 한다.
    - 구체적으로 말하면 데이터를 읽고 쓰려면 셀의 주소 번호를 알아내서 해당 셀과 정보를 주고받아야 한다.
- 메모리에 데이터 쓰고 읽기
    
    ![Untitled](../images/OS%26Logic_6.png)
    
    - 주소버스 : **일정한 메모리 번지를 찾는 데 사용되는 신호를 운반하는 컴퓨터 내의 배선 버스**
    이다. 간단히 말해 물리 주소를 지정하는 데 쓰인다. 주소 버스의 대역은 시스템이 할당할 수 있는 메모리의 양을 결정한다.
        
        → 즉, 어느 셀의 데이터를 가져오고 저장할지
        
    - 데이터버스 : 데이터를 표현할 때 쓰이는 버스이다.
    - 제어버스 : 메모리에 쓸 지, 읽는 건지, I/O장치에 쓸지 읽을지를 정하는 버스

<br>

## 5. 운영체제가 여러 프로그램을 동시에 실행하는 원리에 대해 설명해주세요.

### 답변

OS는 다중 프로그래밍 환경을 구현하기 위해 컨텍스트 스위칭이라는 기능을 제공합니다. 이는 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업을 뜻합니다. 이 작업이 빠르게 일어나면서 실제 여러 프로그램을 사용하는 사용자 입장에서는 동시에 실행하는 것처럼 보이는 것입니다.

### 추가 내용

1. Context Switch가 발생하는 경우는 멀티태스킹, 인터럽트 핸들링, 사용자 모드와 커널 모드 간의 전환까지, 크게 3가지가 존재한다.
    - 멀티태스킹(Multitasking)
        - 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아가며 수행되는 것을 말한다.
        - 번갈아 가며 프로세스가 CPU를 할당 받는데 이때 Context Switching 한다.
        - 사용자가 체감하기 힘든 속도로 Context Switching되며 프로세스가 처리되기 때문에 동시에 처리되는 것처럼 느껴진다.
    - 인터럽트 핸들링(Interrupt handling)
        - 인터럽트란 컴퓨터 시스템에서 예외 상황이 발생했을때 CPU에게 알려 처리할 수 있도록 하는 것을 말한다.
        - 인터럽트가 발생하면 Context Switching한다.
        - I/O request : 입출력 요청
        - time slice expired : CPU 사용시간이 만료
        - fork a child : 자식 프로세스 생성
        - wait for an interrupt : 인터럽트 처리 대기
    - 사용자와 커널 모드 전환(User and kernel mode switching)
        - 사용자와 커널 모드 전환은 Context Switch가 필수는 아니지만 운영체제에 따라 발생할수 있다
        
2. 컨텍스트 스위칭은 **PCB(Process Context/Control Block)**이라고 하는 메모리의 별도 공간에 process 상태값들을 저장하고, 해당 값들을 찾는 방법으로 구현된다. PCB는 프로세스가 실행중인 상태를 스냅샷 찍어 저장하는 공간이라고 생각하면 된다. PCB에 저장되는 내용은 다음과 같다.
    - Process ID (PID)
    - 레지스터 값 (PC, SP 등)
    - Scheduling info (프로세스 상태)
    - Meomory info (메모리 사이즈 linit) - 전체 프로세스 사이즈 등
    - 기타
    
    리눅스의 PCB는 C 구조를 따르는데, 이는 리눅스가 C언어로 작성되었기 때문이다.
    
    ![https://blog.kakaocdn.net/dn/symTO/btrpaHBFPyP/O0EcjEfo2sNhsrcYIgQ0Kk/img.png](https://blog.kakaocdn.net/dn/symTO/btrpaHBFPyP/O0EcjEfo2sNhsrcYIgQ0Kk/img.png)
    
    가장 위의 ID부분은 process의 id를 저장하고, 그 밑단에는 각 processor들의 정보를 저장한다 (e.g. CPU State - 해당 process가 running상태인지, block상태인지..). Priority는 스케줄러가 우선순위를 사용할 경우 해당 프로세스의 우선순위가 저장된다.