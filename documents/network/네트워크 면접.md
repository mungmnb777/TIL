# 네트워크

## 1. Socket으로 바로 통신하는 것 대비 HTTP는 비효율적인데도 왜 많은 앱들은 HTTP를 쓰는 걸까요?

HTTP 방식을 사용하면 매 요청마다 3-way handshake을 해야하기 때문에 속도 면에서는 비효율적일 수 있지만, 클라이언트와 서버가 물리적으로 연결된 것이 아니기 때문에 서버의 부하가 줄어들 수 있습니다. 많은 앱들이 불특정 다수의 사용자를 가지기 때문에 서버의 부하를 줄일 수 있는 HTTP 통신을 사용합니다.

<br>

## 2. OSI Layer 7 또는 TCP Model 에 대해 설명해주세요.

네트워크 프로토콜과 통신을 계층으로써 나눈 것을 말합니다. 표준은 OSI 7 Layer이지만 TCP 모델을 더 많이 사용합니다. TCP 모델은 어플리케이션 레이어, 전송 레이어, 인터넷 레이어, 네트워크 레이어로 나뉘어있으며 어플리케이션 레이어는 유저 영역, 전송 레이어와 인터넷 레이어는 커널 영역, 네트워크 레이어는 하드웨어 영역에 속합니다.

<br>

## 3. 차세대 프로토콜로 논의중인 HTTP/3 은 UDP 기반의 QUIC 이라는 기술로 구현되어 있습니다. UDP 는 TCP 대비 안정성이 떨어지는 프로토콜이라고 하는데, 그럼에도 왜 UDP 를 채택한 걸까요?

UDP는 TCP에 비해 안정성이 떨어지지만 3-way handshake이 없기 때문에 속도가 빠릅니다. 그리고 User Datagram Protocol이라는 이름처럼 사용자가 데이터그램을 커스텀하기가 쉽게 되어있습니다.

따라서 커스텀하기 쉬운 UDP를 이용해 3-way handshake가 아닌 다른 방법으로 신뢰성을 확보하도록 프로토콜을 설계하여 지연 시간을 줄이도록 했습니다.

### 추가 정보

- QUIC의 특징
    - 전송 프로토콜러써 TCP 대신에 UDP를 이용함으로써 프로토콜 업데이트 등이 발생하는 경우 미들박스의 수정이나 OS의 업데이트 없이 사용자 레벨에서 빠른 업데이트가 가능하다.
    - 0 RTT 또는 1 RTT만에 연결 설정이 가능하며 TCP+TLS를 이용하여 실제 데이터를 전송하는 경우 약 4.5 RTT가 걸리는 데 비해 연결 설정이 빠르게 이루어진다.
    - 여러 개의 스트림 간에 독립적인 전송을 가능하게 하여 `Head of Line` 블로킹 현상을 방지한다.
    - 전송되는 패킷마다 새로운 패킷 번호를 할당함으로써 재전송 타이머 계산 시에 발생할 수 있는 모호함을 없앤다.
    - 최대 256개의 SACK 블록을 지원한다.

<br>

## 4. SSL (또는 TLS) 가 어떻게 동작하는지 말씀해주세요.

우선 클라이언트가 특정 주소에 접근할 때, 해당 서버에 ClientHello 요청을 보냅니다. 이 요청에서 클라이언트의 주요 정보를 서버에 보냅니다. 이 때 클라이언트가 어떤 암호화를 사용할 수 있는 지에 대한 정보를 보냅니다.

그 후 서버에서는 ServerHello 응답을 보냅니다. 이 때 인증서 정보와 서버 공개키가 전달됩니다. 서버의 공개키로 데이터를 암호화하면 서버는 이를 받아 개인키로 복호화하여 요청을 분석할 수 있습니다.

다음에 클라이언트에서 인증서 정보가 CA에 의해 발급된 것인지 확인한 후 ClientHello의 랜덤 난수와 ServerHello의 랜덤 난수를 조합해 pre master secret을 생성합니다. pre master secret을 서버의 공개키로 암호화한 후 서버로 전송합니다.

그 후 pre master secret을 master secret 값으로 만든 후 session key를 생성합니다. 이 session key 값을 이용해 서버와 클라이언트는 대칭키 방식으로 암호화한 후에 주고 받는다.

<br>

## 5. HTTP 는 Stateless (상태가 없는) 통신 프로토콜이라고 합니다. 따라서, 상태가 없다면 가령 HTTP 를 쓰는 서비스는 매번 로그인을 해 줘야 하거나 사용자 정보를 저장하는 일이 불가능합니다. 그런데 실제론 그렇지 않죠. 어떻게 이런 불편함을 해소했을까요?

쿠키와 세션을 이용해서 로그인한 사용자의 정보를 유지합니다. 클라이언트가 서버의 페이지를 요청하는 경우 서버에서는 HTTP 요청 헤더의 Cookie를 보고 세션 아이디가 존재하는지 확인한 후, 없다면 세션 아이디를 만들어 클라이언트에 돌려줍니다. 그 후 사용자가 로그인하면 로그인 정보를 해당 세션 아이디의 저장소에 저장합니다. 이후 재접속시 세션 아이디를 검색하고, 로그인 정보가 존재한다면 로그인을 지속적으로 유지합니다.

<br>

## 6. 웹 브라우저에 `[https://www.google.com](https://www.google.com/)` URL 을 입력 후 enter 를 쳤을 때 일어나는 과정을 최대한 상세하게 설명해주세요.

우선 캐시에 해당 도메인의 IP 주소가 있는지 찾아봅니다. 만약 없다면 DNS에 요청합니다. 그렇게 구글의 IP 주소를 획득한 후, TCP 연결을 합니다. 연결에 성공하면 HTTP 요청을 통해 해당 서버로부터 데이터를 요청할 수 있습니다. 요청을 받은 구글 서버는 요청받은 데이터를 찾아 HTTP 응답 바디에 담아 다시 클라이언트로 전송합니다. 클라이언트는 HTML 데이터를 받아 브라우저로 렌더링하면 우리가 아는 구글 검색 화면이 등장합니다.

<br>

## 7. HTTP(s) 프로토콜에서 바이너리 데이터를 전송하는 방식에 대해 설명해주세요.

HTTP는 바이너리 데이터를 MIME을 이용하여 전송합니다. MIME은 바이너리 데이터를 Content-Type 정보와 함께 Base64로 인코딩합니다. 이렇게 하는 이유는 시스템 때문입니다. 초기에는 텍스트만을 전송했기 때문에 7비트로 충분했기에, 해당 시스템으로 8비트 바이너리 데이터를 전송할 수 없었습니다. 그렇기에 해당 시스템을 그대로 이용할 수 있도록 바이너리 데이터를 7비트 아스키코드로 변환시켜줍니다. 그런데 아스키코드 중 불안정한 문자가 있기 때문에 이를 제외한 64개의 출력 문자만 사용합니다. 이렇게 인코딩하는 방식을 Base64라고 합니다.

<br>

## 8. Socket으로 웹 페이지를 크롤링하는 HTTP 클라이언트를 직접 구현해야 한다면, 어떻게 하시겠습니까?