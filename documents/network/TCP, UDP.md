# 1. 전송 계층(Transport Layer)

TCP와 UDP가 적용되는 계층이다. 송신자와 수신자의 논리적 연결을 담당하고, 신뢰성 있는 연결을 유지할 수 있도록 도와주는 역할을 한다.

# 2. TCP(Transmission Control Protocol)

## 2.1. IP(Internet Protocol)의 한계

우선 TCP에 대해 이야기하기 전에, TCP를 빼고 IP만으로 데이터가 오고 갈 때 어떤 한계점이 있는지 알아보자.

IP(Internet Protocol)는 데이터를 보내고자 하는 호스트의 주소 정보를 가지고 있기 떄문에 IP 주소로 패킷에 데이터를 담아 보낼 수 있다. 하지만 IP만으로 데이터를 주고받을 때 생기는 문제가 있다.

1. 패킷을 받을 대상이 없거나, 그 대상이 서비스를 제대로 제공하지 못하는 상태여도 클라이언트에서는 패킷을 전송하는 문제가 발생할 수 있다.
2. 중간에 패킷이 사라지거나, 패킷이 원하는 순서로 전송되지 않았을 때 서버에서 이를 확인할 방법이 없다.
3. 같은 호스트에서 통신하는 애플리케이션이 여러 개일 경우 어떤 애플리케이션에 정보를 전달해야 할 지 알 수 없다.

이러한 문제를 해결할 수 있는 키워드가 바로 TCP이다.

## 2.2. TCP란?

TCP는 IP만으로 보낼 때 생기는 문제점을 해결하고자 만들어진 Transport Layer에 위치한 프로토콜이다. TCP는 위의 문제를 해결하기 위해 헤더에 많은 정보를 가지고 있다. SYN, ACK, FIN, Port, Checksum 등 여러 문제를 TCP에서 해결할 수 있다. 그리고 이러한 TCP 헤더와 데이터를 합쳐 세그먼트라고 부른다.

<p align="center">
    <a href="https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">
        <img src="../images/TCP header.png"><br>
        <em>그림 1) TCP 헤더 구조</em>
    </a>
</p>

그림 1을 보면 TCP 헤더가 많은 정보를 가지고 있다는 것을 알 수 있다. 그러면 이러한 정보를 통해 아까 위의 문제를 어떻게 해결하는지 알아보자.

### 2.2.1. 3-way handshaking

아까 IP의 첫 번째 한계가 연결을 신뢰할 수 없다는 점이다. TCP에서는 9개의 1-bit 플래그 중 SYN과 ACK를 이용하여 양쪽 엔드포인트 간 가상의 연결을 맺는데, 이 연결을 3-way handshaking이라고 한다.

과정은 다음과 같다.

1. 송신자가 수신자에게 `SYN` 플래그를 1로 설정한 후 패킷을 보내 통신이 가능한지 확인한다.
2. 수신자가 송신자로부터 `SYN`이 1인 패킷을 받고, `SYN`과 `ACK`을 1로 설정한 후 송신자에게 보내 통신할 준비가 되어있음을 알린다.
3. 송신자가 수신자의 `SYN`, `ACK` 패킷을 받고 `ACK`를 날려 전송을 시작함을 알린다.

이 과정을 통해 우리는 서로 통신이 가능하다는 것을 확인할 수 있게 된다. 이로써 우리는 IP의 첫번째 한계점을 해결할 수 있다.

### 2.2.2. Sequence / Ack Number

데이터가 큰 파일을 전송한다고 가정해보자. 파일이 1KB인데, 세그먼트에 담을 수 있는 데이터가 최대 100byte라고 하면 송신자는 10개의 세그먼트로 나눠 파일을 전송해야 할 것이다. 이 때 순서를 정해서 파일의 데이터가 누락되지 않게 전달하도록 도움을 주는 부분이 바로 Sequence Number와 Ack Number이다.

그렇다면 각각의 이 정보로 어떻게 데이터의 순서 및 누락을 확인할 수 있는지 알아보자.

1. 우선 처음 보내는 세그먼트의 Sequence Number를 0이라고 가정하자. 이 100 byte의 데이터를 담은 세그먼트를 수신자에게 전송한다.
2. 수신자는 정상적으로 세그먼트를 받는다. 이 때 수신자는 0번째 byte부터 99번째 byte까지 제대로 잘 받았고, 다음에 100번째 byte로 시작되는 세그먼트를 받아야 한다고 예상할 수 있기 때문에 Ack Number를 100으로 붙여 응답한다.
3. 그러면 송신자는 이를 확인하고 Seq Number가 100인 세그먼트를 보낸다.
4. 이를 계속 반복한다.

이런 식으로 Sequence Number를 통해 데이터의 순서를 정의하고, 그 순서대로 데이터를 전달하게 된다. 그런데 이 때, 만약 데이터를 보내는 도중 200번 세그먼트가 누락되었을 경우에는 어떻게 될까?

이 경우에는 수신자가 100번 데이터를 받고 200번을 패스하고 300번을 받게 된다는 뜻인데 수신자는 200번을 받지 못했으므로 300번을 받아도 Ack Number를 200으로 설정하여 세그먼트를 보낸다. 그러면 송신자는 수신자가 200번 세그먼트를 받지 못했다는 것을 인지하고 재전송한다.

→ 이 과정을 통해서 양쪽 엔드포인트는 전송되는 데이터에 대해 신뢰를 가질 수 있게 되는 것이다.

### 2.2.3. Port

우리는 호스트 주소만을 가지고도 데이터를 전송할 수는 있다. 다만 그 호스트와 통신할 수 있는 애플리케이션이 여러 개일 경우 이 애플리케이션들에 대해서도 구분할 수 있는 정보가 필요한데, 그게 바로 포트이다.

데이터를 전송할 때 송신자 포트 정보와 수신자 포트 정보를 담아 어떤 애플리케이션에 전송할 데이터인지 또 응답은 어디로 해야하는지 구체화 시켜주는 것이다.

# 3. UDP(User Datagram Protocol)

Transport Layer에는 TCP말고도 UDP라는 프로토콜도 존재한다. UDP는 TCP와 달리 아주 단순한 헤더를 가지고 있다.

<p align="center">
    <a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">
        <img src="../images/UDP header.png"><br>
        <em>그림 2) UDP 헤더 구조</em>
    </a>
</p>

위의 그림을 보면 TCP와의 차이가 확 느껴진다. 진짜 헤더에 뭐가 없다. 그래서 UDP는 3-way handshaking도 없고, 데이터의 신뢰성도 보장되지 않는다. 하지만 그만큼 TCP에 비해 속도가 빠르다. 그렇기 때문에 속도가 중요하고, 데이터가 손실되어도 크게 개의치 않는 동영상 스트리밍 서비스에 이용되는 프로토콜이다.

UDP는 다른 큰 특징은 커스텀하기 좋다는 점이다. 헤더에 포트 정보와 checksum 정도의 최소의 정보만 들어가기 때문에 복잡한 TCP와 달리 사용자 입맛에 맞게 헤더를 바꿀 수 있다.

최근에 HTTP 3.0에서는 UDP를 이용하여 TCP의 연결 지향 웹 애플리케이션을 개선한 QUIC라는 프로토콜을 사용하기로 결정해서 다음 세대의 개발자들은 UDP/IP를 이용한 통신을 하게 될 수도 있을 것 같다.

# 4. 참고자료

[위키백과 - TCP](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)

[위키백과 - UDP](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)

[위키백과 - QUIC](https://ko.wikipedia.org/wiki/QUIC)

[네트워크 엔지니어 환영의 기술 블로그](https://aws-hyoh.tistory.com/57)

[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
