# HTTP 헤더 - 캐시와 조건부 요청

# 캐시 기본 동작

### 첫 번째 요청

웹 브라우저가 API를 통해 어떤 데이터를 요청했을 때 서버는 그에 응답한다. 이 때 서버는 HTTP 헤더에 cache-control: max-age=60이라는 문장을 넣어 보낸다. 그러면 응답 결과를 브라우저 캐시에 60초 동안 저장하게 된다.

### 두 번째 요청

캐시를 뒤졌을 때 응답 결과가 존재하므로 네트워크를 굳이 접속할 필요가 없다.

### 세 번째 요청 - 캐시 시간 초과

캐시 유효 시간을 검증했을 때 60초가 초과했으므로 서버에 다시 요청해야 한다.

### 캐시 적용 장점

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
- 빠른 사용자 경험

---

# 검증 헤더와 조건부 요청 1

### 캐시 시간 초과

- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.
    1. 서버에서 기존 데이터를 변경함
    2. 서버에서 기존 데이터를 변경하지 않음

### Last-Modified

- 데이터 최종 수정일
- 시간 초과된 캐시에 Last-Modified가 있으면 요청 헤더에 if-modified-since라는 키로 서버에 넘긴다.
- 서버에서 요청을 보고 변경 사항이 없으면 304 Not Modifed로 응답한다. 참고로 이 때 HTTP Body는 보내지 않고 캐시에 있는 데이터를 재사용

---

# 검증 헤더와 조건부 요청 2

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since : Last-Modified 사용
- If-None-Match : ETag 사용
- 조건이 만족하면 200 OK
- 조건이 만족하지 않으면 304 Not Modified

### ETag, If-None-Match

- ETag (Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - 파일을 해시 함수에 넣어 해시값을 받는다.
    - 똑같은 파일을 해시 함수에 넣을 경우 결과가 똑같으니 이를 비교한다.
- 데이터가 변경되면 이 이름을 바꾸어서 변경함

### 정리

- 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 이 값을 서버에 제공

---

# 캐시와 조건부 요청 헤더

### Cache-Control

- Cache-Control : max-age → 캐시 유효 시간, 초 단위
- Cache-Control : no-cache → 데이터는 캐시해도 되지만, 항상 Origin 서버에 검증하고 사용
- Cache-Control : no-store → 데이터에 민감한 정보가 있으므로 저장하면 안됨

---

# 캐시 무효화

### 확실한 캐시 무효화 응답

- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache