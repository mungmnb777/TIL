# 쉽게 시작하는 쿠버네티스

날짜: 2022년 12월 18일
카테고리: infra

## 쿠버네티스가 하는 일

컨테이너를 관리해주는 역할(Orchestration)

## 쿠버네티스는 어떻게 구성되어 있을까?

### 네임스페이스

쿠버네티스 클러스터 내의 논리적인 분리 단위

## 쿠버네티스의 기본 철학

MSA처럼 구성되어 있음 → 각자의 feature들이 각자가 할 일만 열심히 한다

### 파드가 배포되면?

- API 서버
    - 사용자로부터 쿠버네티스 API를 받는 역할
    - 요청을 받은 후 각각의 feature들이 제대로 일을 하는지 감시하는 역할
- 컨트롤러 매니저
    - 파드를 생성하는 역할
- 스케줄러
    - 새로운 파드가 워커 노드에 들어가도록 스케줄링하는 역할
- kubelet
    - 워커 노드 내부에서 파드 동작을 관리하는 역할
    - 컨테이너 런타임에 컨테이너를 생성하도록 요청

### 선언적인 시스템

추구하는 상태와 현재 상태를 맞추려고함 → 그러면 API 서버가 상태를 가지고 있고 CM, 스케줄러, kubelet이 그 상태를 최적의 상태로 맞추기 위해 조절하는 느낌으로 작동하는 걸까?

### API 서버 vs etcd

- API 서버는 클러스터의 업데이트된 정보를 etcd에 기록한다. (etcd는 약간 DB 느낌)

## 파드에 문제가 생긴다면

쿠버네티스는 파드를 삭제될 수 있다고 생각한다. Deployment는 삭제되는 것을 가정하고 다시 생성할 수 있도록 한다. (만약 파드 단일로 구성되어 있었다면 삭제되면 그냥 사라짐)

## 쿠버네티스의 워커 노드의 구성 요소에 문제가 생긴다면

kubelet에 문제가 생기면 pod 배포가 되지 않는다. (`systemctl stop kubelet`)

컨테이너 런타임에 문제가 생기면 새로 생길 파드는 다른 워커 노드에서 생성한다. 그리고 현재 있는 파드의 경우에는 evict 타임(약 5분)이 지난 후에 다른 워커 노드로 옮겨간다.(`systemctl stop containerd`)

## 쿠버네티스의 마스터 노드의 구성 요소에 문제가 생긴다면

## 쿠버네티스에서 스케일 아웃, 스케일 인이 왜 필요할까?

쿠버네티스는 단일 컴퓨터에다가 오토 스케일링을 하게 될 것임

그런데 물리적인 리소스가 늘어나지 않는 환경에서 컨테이너를 늘린다고 해서 커지는 부하를 감당하는데 이득이 있을까?